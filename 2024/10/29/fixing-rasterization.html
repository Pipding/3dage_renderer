<!DOCTYPE html>

<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="icon" href="/3dage_renderer/assets/images/favicon.ico">

  <title>
    Texture and Depth - Coordinates to Canvas
    
  </title>

  <meta name="description" content="Let’s remind ourselves of the state of my render at the end of last week’s blog post.">

  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/3dage_renderer/assets/main.css">
  <link rel="canonical" href="https://pipding.github.io//3dage_renderer/2024/10/29/fixing-rasterization.html">
  <link rel="alternate" type="application/rss+xml" title="Coordinates to Canvas" href="/3dage_renderer/feed.xml">

</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/3dage_renderer/">Coordinates to Canvas</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/3dage_renderer/renderer">Renderer</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/3dage_renderer/assets/images/2024_10_22_bad_texture.gif')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <div class="post-heading">
            <h1>Texture and Depth</h1>
            
            <h2 class="subheading">Figuring out where I went so wrong with rasterization, week ending 2024-10-29</h2>
            
            <span class="meta">Posted by
              <a href="#">Ryan</a>
              on October 29, 2024 &middot; <span class="reading-time" title="Estimated read time">
  
   11 mins  read </span>

            </span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">

        <p>Let’s remind ourselves of the state of my render at the end of last week’s blog post.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_22_bad_texture.gif" alt="An animated image showing a rendered image of a basketball with a very glitchy appearance and half the basketball missing." style="max-width: 100%; height: auto;" />
</p>

<p>Oof. Ok, so what was wrong?</p>

<h1 id="debugging-the-rasterization-code">Debugging the rasterization code</h1>
<p>I started with basically no idea what was going on. I couldn’t formulate any theories about what could be going wrong to mangle the renderer so much, but after staring at it and thinking for a while, I noticed the following symptoms;</p>
<ol>
  <li>Lots of triangles are being rendered black when they shouldn’t be.
    <ul>
      <li>This suggests that the mesh is being loaded correctly, because the errors appear to be happening to specific triangles</li>
    </ul>
  </li>
  <li>Two large chunks of the basketball are missing on opposite sides
    <ul>
      <li>This suggests something weird is happening with the texture, rather than the rasterization code itself</li>
    </ul>
  </li>
</ol>

<p>So to debug this I made a very simple code change. Instead of sampling colour data from the diffuse map I just set the colour of every pixel to magenta and…
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_magenta_ball.gif" alt="An animated image showing a rendered magenta ball with a white wireframe." style="max-width: 100%; height: auto;" />
</p>

<p>The ball looks much better. The large chunks on either side are no longer there, so this does indeed suggest there’s some sort of problem with sampling the texture. To get some better insight into this, I replaced the basketball texture (<code class="language-plaintext highlighter-rouge">basketball_d.png</code>) with a test texture. Test textures are a common method of debugging UV issues and I grabbed this one from <a href="https://en.wikipedia.org/wiki/UV_mapping">Wikipedia</a>.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_uv_test_image.jpg" alt="An animated image showing a rendered magenta ball with a white wireframe." style="max-width: 100%; height: auto;" />
</p>

<p>When I replaced my texture with this one, here’s what I saw.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_uv_test_overdraw.gif" alt="An animated image showing a rendered ball with a test texture applied and significant glitchy visuals." style="max-width: 100%; height: auto;" />
</p>

<p>This is what’s called <a href="https://developer.android.com/topic/performance/rendering/overdraw#:~:text=Overdraw%20refers%20to%20the%20system's,the%20cards%20in%20the%20stack.">overdraw</a>. The rasterizer is iterating through every triangle in the mesh and drawing its pixels to the screen - even if those pixels are hidden behind something else. In short, it’s drawing both the front and the back of the ball at the same time. This is a problem which can be solved by introducing a depth buffer (also called a <a href="https://en.wikipedia.org/wiki/Z-buffering">z-buffer</a>).</p>

<h1 id="adding-a-depth-buffer">Adding a depth buffer</h1>
<p>Mercifully, adding a depth buffer isn’t too complex.<br />
<strong>Note:</strong> At this point I’d like to interrupt myself to point out that the rendering code I’m writing is <em>very</em> naive. It is neither robust nor performant, so when I say “adding a depth buffer isn’t complex”, I’m only talking about the most basic form of depth buffer.</p>

<h3 id="what-is-a-depth-buffer">What is a depth buffer?</h3>
<p>Simply put, whenever we draw a pixel to the screen, we’re going to take a note of the distance between that pixel and the camera. This distance will be the “depth” of that pixel. If we ever try to draw something on that pixel again, we’ll check the buffer to see if it has been drawn before. If it has been drawn before, we’ll check whether the new thing we’re trying to draw is closer to the camera than the previous one. If it is, we draw it and update the depth buffer. If not, we simply skip the draw call.</p>

<p>First thing’s first, we create the depth buffer. The size of the buffer depends on the size of the screen we’re rendering to, as we’ll need one entry per pixel. We’ll set the initial values to “Infinity”, simulating an object drawn infinitely far away (thus anything should be closer). This depth buffer will be cleared at the start of each frame.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>depthBuffer =  Array(canvas.width).fill().map(() =&gt; Array(canvas.width).fill(Infinity));
</code></pre></div></div>
<p>The next change comes inside the <code class="language-plaintext highlighter-rouge">rasterizeTriangle</code> function. Last week I discussed how we created a bounding box around each triangle in the mesh so we could limit the number of pixels we need to check while rasterizing. This week, we’ll make a slight tweak. We’ll use the <code class="language-plaintext highlighter-rouge">Floor</code> and <code class="language-plaintext highlighter-rouge">Ceil</code> functions to round the coordinates which define those bounds to the nearest whole number. We do this because the bounds will now be used as indices in the depth buffer array.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const minX = Math.floor(Math.min(v0.x, v1.x, v2.x));
const maxX = Math.ceil(Math.max(v0.x, v1.x, v2.x));
const minY = Math.floor(Math.min(v0.y, v1.y, v2.y));
const maxY = Math.ceil(Math.max(v0.y, v1.y, v2.y));
</code></pre></div></div>

<p>Now, to calculate the depth of a given point we’d do something like this.<br />
<code class="language-plaintext highlighter-rouge">const depth = (u * v0.z) + (v * v1.z) + (w * v2.z);</code>.<br />
<br />
But there’s a problem. The triangles we’re rasterizing have already been projected into screen space, meaning they’re 2-dimensional and therefore don’t have a depth (<code class="language-plaintext highlighter-rouge">z</code>) component! Cauchemar!
<br />
Thankfully there’s a simple fix. If we go back to our <code class="language-plaintext highlighter-rouge">projectVertex</code> function, the X and Y coordinates of the projected triangles were defined like this.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function projectVertex(vertex) {
    ...

    const translatedVertex = {
        x: vertex.x - camera.position.x,
        y: vertex.y - camera.position.y
    };

    return {
        x: (translatedVertex.x/(translatedVertex.z * tanHalfFOV)) * screenHalfWidth + screenHalfWidth,
        y: (translatedVertex.y/(translatedVertex.z * tanHalfFOV)) * screenHalfHeight * aspectRatio + screenHalfHeight
    };
}
</code></pre></div></div>
<p><br />
All we need to do, then, is retain the Z coordinate like this.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function projectVertex(vertex) {

    const translatedVertex = {
        x: vertex.x - camera.position.x,
        y: vertex.y - camera.position.y,
        z: vertex.z - camera.position.z
    };

    return {
        x: (translatedVertex.x/(translatedVertex.z * tanHalfFOV)) * screenHalfWidth + screenHalfWidth,
        y: (translatedVertex.y/(translatedVertex.z * tanHalfFOV)) * screenHalfHeight * aspectRatio + screenHalfHeight,
        z: translatedVertex.z
    };
}
</code></pre></div></div>
<p><br />
We don’t even need to calculate perspective for the Z coordinate because it doesn’t have any impact on the rendered image, it’ll only be used for depth calculation. With the z coordinate now included in our projected vertices, we can use it to calculate pixel depth and update the depth buffer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function rasterizeTriangle(ctx, v0, v1, v2, uv0, uv1, uv2) {
    ...

    // Loop through all pixels in the bounding box
    for (let y = minY; y &lt;= maxY; y++) {
        for (let x = minX; x &lt;= maxX; x++) {
            // Calculate the depth of the pixel
            const depth = (u * v0.z) + (v * v1.z) + (w * v2.z);

            // Check if the pixel in 3D space we're trying to draw is 
            // closer to the camera than any previous pixel
            if (depth &lt; depthBuffer[x][y]) {
                depthBuffer[x][y] = depth; // Update the depth buffer
                // ...
            }
        }
    }
}
</code></pre></div></div>

<p>After implementing this simple(-ish) change, here’s what we see.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_rasterized_with_depth.gif" alt="An animated image showing a rendered ball with a test texture applied correctly." style="max-width: 100%; height: auto;" />
</p>

<p>The framerate is still abysmal but it’s a great improvement in terms of UV. So, if we go back to our basketball texture we’ll see…
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_basketball_missing_chunks.gif" alt="An animated image showing a rendered basketball with squares missing from the texture on two sides." style="max-width: 100%; height: auto;" />
</p>
<p>We’ve solved one of the problems, but there are still chunks of texture missing on either side.</p>

<h2 id="investigating-the-missing-chunks">Investigating the missing chunks</h2>
<p>There’s a significant clue in the previous stage about what could be going wrong here. As part of debugging all those weird triangles, we changed the texture sampling code to render a solid colour, which resulted in a properly rendered sphere. Then, we applied the test pattern which rendered correctly. This suggests there’s a problem with our texture. Actually, though… if we look at the rendered test pattern there’s something unusual about it.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_rasterized_with_depth.gif" alt="An animated image showing a rendered ball with a test texture applied correctly." style="max-width: 100%; height: auto;" />
</p>
<p>The text is back-to-front and upside-down. This suggests our texture data is somehow being read or applied backwards. Now to be honest, I don’t yet understand what’s causing this problem - that will be a problem to investigate over the coming week. What I do know though is that we can invert the texture data very easily. UV coordinates are normalised, meaning they’re all given in the range 0 -&gt; 1. This means if you want to flip UVs, all you have to do is subtract the UV coordinate from 1. Imagine having a coordinate <code class="language-plaintext highlighter-rouge">(0.2, 0.2)</code>. What’s the opposite of that? <code class="language-plaintext highlighter-rouge">(1  - 0.2, 1 - 0.2)</code> or <code class="language-plaintext highlighter-rouge">(0.8, 0.8)</code>. In code, here’s how we do it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const interpolatedUV = new THREE.Vector2(
    (u * uv0.x + v * uv1.x + w * uv2.x),
    (u * uv0.y + v * uv1.y + w * uv2.y)
);
</code></pre></div></div>

<p>becomes</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const interpolatedUV = new THREE.Vector2(
    (u * uv0.x + v * uv1.x + w * uv2.x),
    1 - (u * uv0.y + v * uv1.y + w * uv2.y)
);
</code></pre></div></div>

<p>And with this simple inversion, we’re rasterizing correctly.
<br /></p>
<p style="text-align: center;">
  <img src="/3dage_renderer/assets/images/2024_10_29_rasterized_basketball.gif" alt="An animated image showing a rendered ball with a correctly-applied diffuse map." style="max-width: 100%; height: auto;" />
</p>


        <hr>

        <div class="clearfix">

          
          <a class="btn btn-primary float-left" href="/3dage_renderer/2024/10/22/start-rasterizing.html" data-toggle="tooltip" data-placement="top" title="Putting meat on the bones">&larr; Previous<span class="d-none d-md-inline">
              Post</span></a>
          
          
          <a class="btn btn-primary float-right" href="/3dage_renderer/2024/11/05/optimisation_round_one.html" data-toggle="tooltip" data-placement="top" title="A Boost in Performance">Next<span class="d-none d-md-inline">
              Post</span> &rarr;</a>
          

        </div>

      </div>
    </div>
  </div>


  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          
          
          
          
          
        </ul>
        <p class="copyright text-muted">Copyright &copy;  2024</p>
      </div>
    </div>
  </div>
</footer>


  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/3dage_renderer/assets/vendor/startbootstrap-clean-blog/js/scripts.js"></script>

<script src="/3dage_renderer/assets/scripts.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '');
</script>



</body>

</html>
